<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 0;
        padding: 0;
        background: #fff;
      }
      #container {
        max-width: 650px;
        margin: 0 auto;
        padding: 2vw 2vw 3vw 2vw;
        min-height: 100vh;
        text-align: center;
      }
      h2 {
        font-size: 2.2rem;
        margin: 2rem 0 1rem 0;
        text-align: center;
      }
      label {
        font-size: 1.15rem;
        display: block;
        text-align: center;
      }
      input[type="text"] {
        font-size: 1.25rem;
        padding: 0.9rem;
        border-radius: 0.6rem;
        border: 1px solid #bbb;
        width: 82vw;
        max-width: 390px;
        margin-top: 0.3em;
        margin-bottom: 1.3em;
        display: block;
        margin-left: auto;
        margin-right: auto;
        text-align: center;
      }
      .btn-group {
        display: flex;
        justify-content: center;
        gap: 12px;
        margin-bottom: 1.3em;
      }
      button {
        font-size: 1.25rem;
        padding: 1rem 2.2rem;
        border-radius: 0.7rem;
        border: none;
        background: #0078d7;
        color: #fff;
        margin: 0.7rem 0.7rem 0.7rem 0;
        cursor: pointer;
        transition: background 0.15s;
      }
      button:disabled {
        background: #ccc;
        cursor: not-allowed;
      }
      #status {
        font-size: 1.18rem;
        margin: 1.2rem 0 0.5rem 0;
        min-height: 2rem;
      }
      #prettyResult {
        font-size: 1.13rem;
        margin: 1.1rem auto 0 auto;
        width: 100%;
        max-width: 620px;
        background: #f7f7f7;
        border-radius: 1rem;
        padding: 1.15rem;
        word-break: break-word;
        overflow-x: auto;
        box-sizing: border-box;
        text-align: center;
      }
      .score-table {
        border-collapse: collapse;
        margin: 1em auto 0 auto;
        width: 95%;
        font-size: 1.09rem;
        background: #fff;
      }
      .score-table th,
      .score-table td {
        border: 1px solid #bbb;
        padding: 10px 10px;
        text-align: center;
        white-space: nowrap;
      }
      .score-table th {
        background: #f3f7fa;
        font-size: 1.09rem;
        font-weight: bold;
      }
      .score-good {
        color: #2a7a19;
        font-weight: bold;
      }
      .score-warn {
        color: #e6a700;
        font-weight: bold;
      }
      .score-bad {
        color: #d43c2c;
        font-weight: bold;
      }
      .tooltip {
        position: relative;
        cursor: pointer;
        border-bottom: 1px dotted #888;
        margin-left: 3px;
        display: inline-block;
      }
      .tooltip .tooltiptext {
        visibility: hidden;
        width: 210px;
        background-color: #444;
        color: #fff;
        text-align: left;
        border-radius: 5px;
        padding: 10px;
        position: absolute;
        z-index: 2;
        top: 110%;
        left: 50%;
        transform: translateX(-50%);
        opacity: 0;
        transition: opacity 0.4s;
        font-size: 1.08em;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        pointer-events: none;
      }
      .tooltip:hover .tooltiptext {
        visibility: visible;
        opacity: 1;
        pointer-events: auto;
      }
      .tips-section {
        margin: 20px 0 13px 0;
        color: #244f8f;
        text-align: left;
        display: inline-block;
      }
      .raw-data-section {
        background: #f3f3f3;
        margin: 1em auto;
        padding: 15px;
        border-radius: 6px;
        font-size: 1.16em;
        max-width: 96vw;
        max-height: 340px;
        overflow: auto;
        display: none;
        text-align: left;
      }
      .show-raw-link {
        cursor: pointer;
        color: #0083ff;
        text-decoration: underline;
        font-size: 1.12em;
        margin-left: 8px;
      }
      @media (max-width: 650px) {
        #container {
          padding: 1vw 0.5vw 4vw 0.5vw;
        }
        h2 {
          font-size: 1.5rem;
        }
        #prettyResult,
        .score-table th,
        .score-table td {
          font-size: 1.04rem;
        }
        button,
        input[type="text"],
        #status {
          font-size: 1rem;
        }
        input[type="text"] {
          width: 95vw;
          max-width: 99vw;
        }
      }
    </style>
  </head>
  <body>
    <div id="container">
      <h2>Pronunciation Test</h2>
      <label>
        Enter reference text:<br />
        <input id="referenceText" value="Hello world" type="text" />
      </label>
      <div class="btn-group">
        <button id="record">Record</button>
        <button id="stop" disabled>Stop</button>
      </div>
      <p id="status">Not recording</p>
      <div id="prettyResult"></div>
      <div>
        <span class="show-raw-link" id="toggleRaw">Show Raw Data</span>
        <pre id="rawData" class="raw-data-section"></pre>
      </div>
    </div>
    <script>
      let mediaRecorder,
        audioChunks = [];
      let isAnalyzing = false;

      document.getElementById("record").onclick = async () => {
        audioChunks = [];
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        });
        mediaRecorder = new MediaRecorder(stream);

        // Attach ondataavailable each time (working version)
        mediaRecorder.ondataavailable = (e) => audioChunks.push(e.data);

        // Always attach onstop handler here (working version)
        mediaRecorder.onstop = async () => {
          const blob = new Blob(audioChunks, { type: "audio/wav" });
          const formData = new FormData();
          formData.append("audio", blob);
          formData.append(
            "text",
            document.getElementById("referenceText").value
          );

          const response = await fetch(
            "https://luxury-language-api.vercel.app/api/assess",
            {
              method: "POST",
              body: formData,
            }
          );
          let data;
          try {
            data = await response.json();
          } catch {
            data = { error: "Could not parse server response." };
          }
          showPrettyResults(data);
          showRawData(data);
        };

        mediaRecorder.start();
        document.getElementById("status").textContent = "Recording...";
        document.getElementById("record").disabled = true;
        document.getElementById("stop").disabled = false;
        document.getElementById("prettyResult").innerHTML = "";
      };

      document.getElementById("stop").onclick = () => {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
          document.getElementById("status").textContent = "Analyzing...";
          document.getElementById("stop").disabled = true;
          document.getElementById("record").disabled = false;
          document.getElementById(
            "prettyResult"
          ).innerHTML = `<div style="font-size:1.18em;margin-top:12px;color:#777;">Analyzing...</div>`;
          isAnalyzing = true;
        }
      };

      document.getElementById("toggleRaw").onclick = () => {
        const raw = document.getElementById("rawData");
        raw.style.display = raw.style.display === "block" ? "none" : "block";
        document.getElementById("toggleRaw").textContent =
          raw.style.display === "block" ? "Hide Raw Data" : "Show Raw Data";
      };

      function scoreClass(score) {
        if (score === null || score === undefined) return "";
        if (score >= 85) return "score-good";
        if (score >= 70) return "score-warn";
        return "score-bad";
      }

      function showPrettyResults(data) {
        isAnalyzing = false;
        const $out = document.getElementById("prettyResult");
        if (!data || data.error) {
          $out.innerHTML = `<span class="score-bad">Error: ${
            data?.error || "Unknown"
          }</span>`;
          return;
        }
        const nbest = data.NBest && data.NBest[0];
        if (!nbest) {
          $out.innerHTML = "<span>No analysis returned.</span>";
          return;
        }
        // Tooltips
        const exp = {
          Accuracy: "How close your pronunciation is to a native speaker.",
          Fluency: "How smooth and natural your speech was.",
          Completeness: "Did you say all the words in the reference?",
          PronScore: "Overall pronunciation quality.",
          Phoneme: "The smallest possible sound in a language.",
        };
        // Scores
        const scores = [
          ["Accuracy", nbest.AccuracyScore],
          ["Fluency", nbest.FluencyScore],
          ["Completeness", nbest.CompletenessScore],
          ["Pronunciation", nbest.PronScore],
        ];
        let html = `
        <div>
          <b>Your Results:</b><br>
          <span>
            ${scores
              .map(
                ([k, v]) => `
              <span class="${scoreClass(v)}">${k}
                <span class="tooltip">(?)<span class="tooltiptext">${
                  exp[k] || ""
                }</span></span>: ${v !== undefined ? v + "%" : "â€“"}</span>
            `
              )
              .join(" | ")}
          </span>
        </div>
        <div style="margin:13px 0 0 0;"><b>What you said:</b> "${
          data.DisplayText || nbest.Display || "(No speech detected)"
        }"</div>
        <table class="score-table"><thead>
        <tr>
          <th style="min-width:72px;">Word</th>
          <th style="min-width:80px;">Score</th>
          <th style="min-width:80px;">Error</th>
          <th style="min-width:150px;">Phonemes <span class="tooltip">(?)<span class="tooltiptext">${
            exp.Phoneme
          }</span></span></th>
        </tr>
        </thead><tbody>
        `;
        (nbest.Words || []).forEach((word) => {
          let err =
            word.ErrorType && word.ErrorType !== "None" ? word.ErrorType : "";
          html += `<tr>
            <td>${word.Word}</td>
            <td class="${scoreClass(word.AccuracyScore)}">${
            word.AccuracyScore !== undefined ? word.AccuracyScore + "%" : "â€“"
          }</td>
            <td>${err}</td>
            <td>${(word.Phonemes || [])
              .map(
                (p) =>
                  `<span class="${scoreClass(p.AccuracyScore)}">${p.Phoneme} (${
                    p.AccuracyScore !== undefined ? p.AccuracyScore + "%" : "â€“"
                  })</span>`
              )
              .join(", ")}</td>
          </tr>`;
        });
        html += "</tbody></table>";

        // Tips: only top 4 lowest scores
        let tips = [];
        (nbest.Words || []).forEach((word) => {
          (word.Phonemes || []).forEach((p) => {
            if (p.AccuracyScore !== undefined && p.AccuracyScore < 85)
              tips.push({
                text: `Try practicing ${word.Word} - the sound "${p.Phoneme}" was weak (${p.AccuracyScore}%)`,
                score: p.AccuracyScore,
              });
          });
        });
        tips.sort((a, b) => a.score - b.score);
        if (tips.length)
          html += `<div class="tips-section"><b>Tips for You:</b><ul>${tips
            .slice(0, 4)
            .map((t) => `<li>${t.text}</li>`)
            .join("")}</ul></div>`;
        else
          html += `<div class="tips-section"><b>Tips for You:</b> No major errorsâ€”great job!</div>`;

        $out.innerHTML = html;
      }

      // Raw data with only useful fields
      function showRawData(data) {
        function filter(data) {
          if (!data || typeof data !== "object") return data;
          const cleaned = {};
          for (const k in data) {
            if (
              [
                "Offset",
                "SNR",
                "ITN",
                "MaskedITN",
                "RecognitionStatus",
              ].includes(k) ||
              (k === "Words" && Array.isArray(data[k]))
            )
              continue;
            if (Array.isArray(data[k]) && k === "NBest") {
              cleaned[k] = data[k].map((nb) => {
                const nb2 = { ...nb };
                delete nb2.Offset;
                delete nb2.SNR;
                delete nb2.ITN;
                delete nb2.MaskedITN;
                if (Array.isArray(nb2.Words)) {
                  nb2.Words = nb2.Words.map((w) => {
                    const w2 = { ...w };
                    delete w2.Offset;
                    delete w2.Syllables;
                    if (Array.isArray(w2.Phonemes)) {
                      w2.Phonemes = w2.Phonemes.map((p) => {
                        const p2 = { ...p };
                        delete p2.Offset;
                        return p2;
                      });
                    }
                    return w2;
                  });
                }
                return nb2;
              });
            } else {
              cleaned[k] = filter(data[k]);
            }
          }
          return cleaned;
        }
        document.getElementById("rawData").textContent = JSON.stringify(
          filter(data),
          null,
          2
        );
      }
    </script>
  </body>
</html>

    </script>
  </body>
</html>
